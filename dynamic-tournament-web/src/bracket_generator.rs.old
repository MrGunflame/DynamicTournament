mod bracket_generator;

/// A tournament bracket generator system.
pub trait System {}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Match<T> {
    pub entrants: [EntrantSpot<T>; 2],
}

#[derive(Clone, Debug, Default)]
pub struct SingleElimination<T> {
    matches: Vec<Match<T>>,
    num_teams: usize,
}

// FIXME: Remove requirement for T: Clone.
impl<T> SingleElimination<T>
where
    T: Clone,
{
    pub fn new(entrants: Vec<T>) -> Self {
        let num_matches = ((entrants.len() / 2) << 1) - 1;
        let mut matches = Vec::with_capacity(num_matches);

        // Ground 2 teams into a match. (i and i + 1)
        let mut i = 0;
        while i < entrants.len() {
            let team1 = match entrants.get(i).cloned() {
                Some(e) => EntrantSpot::Entrant(e),
                None => EntrantSpot::Empty,
            };
            let team2 = match entrants.get(i + 1).cloned() {
                Some(e) => EntrantSpot::Entrant(e),
                None => EntrantSpot::Empty,
            };

            matches.push(Match {
                entrants: [team1, team2],
            });

            i += 2;
        }
        i /= 2;

        // Fill with matches for next rounds.
        while i < matches.capacity() {
            matches.push(Match {
                entrants: [EntrantSpot::TBD, EntrantSpot::TBD],
            });

            i += 1;
        }

        debug_assert_eq!(matches.len(), num_matches);

        Self {
            matches,
            num_teams: entrants.len(),
        }
    }

    pub fn matches(&self) -> &[Match<T>] {
        &self.matches
    }

    pub fn rounds_iter(&self) -> RoundsIter<'_, T> {
        RoundsIter::new(&self.matches, self.num_teams / 2)
    }

    /// Calls `f` on the match with the given index, which causes the bracket to update.
    pub fn update_match<F: FnOnce(&mut Match<T>)>(
        &mut self,
        round_index: usize,
        match_index: usize,
        winner: Winner,
        f: F,
    ) -> usize {
        let index = self.update_match_standalone(round_index, match_index, f);

        let prev_match = self.matches[index].clone();

        // Update next match
        if (self.num_teams / 2) >> 2 > 1 {
            self.update_match_standalone(round_index + 1, match_index >> 1, move |m| {
                m.entrants[match_index % 2] = match winner {
                    Winner::Team1 => prev_match.entrants[0].clone(),
                    Winner::Team2 => prev_match.entrants[1].clone(),
                    Winner::None => EntrantSpot::TBD,
                };
            });
        }

        index
    }

    /// Calls `f` on the match with the given index without updating the bracket.
    pub fn update_match_standalone<F>(
        &mut self,
        round_index: usize,
        match_index: usize,
        f: F,
    ) -> usize
    where
        F: FnOnce(&mut Match<T>),
    {
        // FIXME: Optimize this shit.
        let mut start = self.num_teams / 2;
        let mut index = 0;
        for _ in 0..round_index {
            index += start;
            start = start >> 1;
        }
        index += match_index;

        f(&mut self.matches[index]);

        index
    }

    pub fn num_teams(&self) -> usize {
        self.num_teams
    }
}

pub struct RoundsIter<'a, T> {
    // Number of matches in the next round.
    num_matches: usize,
    index: usize,
    // Slice into the full buffer of the Vec.
    slice: &'a [Match<T>],
}

impl<'a, T> RoundsIter<'a, T> {
    fn new(slice: &'a [Match<T>], num_matches: usize) -> Self {
        Self {
            num_matches,
            slice,
            index: 0,
        }
    }
}

impl<'a, T> Iterator for RoundsIter<'a, T> {
    type Item = &'a [Match<T>];

    fn next(&mut self) -> Option<Self::Item> {
        if self.index > 1 {
            let slice = &self.slice[self.index..self.index + self.num_matches];
            self.index += self.num_matches;
            self.num_matches /= 2;

            return Some(slice);
        }

        None
    }
}

#[derive(Copy, Clone)]
pub enum Winner {
    Team1,
    Team2,
    None,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum EntrantSpot<T> {
    Entrant(T),
    /// A spot predefined empty.
    Empty,
    TBD,
}

// #[cfg(test)]
// mod tests {
//     use super::{Entrant, Match, SingleElimination};

//     #[test]
//     fn test_single_elimination() {
//         let tournament = SingleElimination::new(vec![
//             Entrant { id: 0 },
//             Entrant { id: 1 },
//             Entrant { id: 2 },
//             Entrant { id: 3 },
//             Entrant { id: 4 },
//             Entrant { id: 5 },
//             Entrant { id: 6 },
//             Entrant { id: 7 },
//         ]);

//         assert_eq!(
//             tournament.matches(),
//             [
//                 Match {
//                     entrants: [Some(Entrant { id: 0 }), Some(Entrant { id: 1 })],
//                 },
//                 Match {
//                     entrants: [Some(Entrant { id: 2 }), Some(Entrant { id: 3 })],
//                 },
//                 Match {
//                     entrants: [Some(Entrant { id: 4 }), Some(Entrant { id: 5 })],
//                 },
//                 Match {
//                     entrants: [Some(Entrant { id: 6 }), Some(Entrant { id: 7 })],
//                 },
//                 Match {
//                     entrants: [None, None],
//                 },
//                 Match {
//                     entrants: [None, None],
//                 },
//                 Match {
//                     entrants: [None, None],
//                 }
//             ]
//         );
//     }
// }
